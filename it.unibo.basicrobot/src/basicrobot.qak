System basicrobot 

mqttBroker "localhost" : 1883    //192.168.1.18  192.168.43.229 192.168.137.1

Event  userCmd      : userCmd(X)	//from GUI X = w | a | s | d | h 
Event  maitreCmd	: maitreCmd(X)
Event  plannerCmd	: plannerCmd(X)
Event  ackMsg		: ackMsg(X)
Event  fridgeRequest : fridgeRequest(X)
Event  recvFoodMsgEvent : recvFoodMsgEvent(X)
Event  endTaskEventCmd : endTaskEventCmd(X)
Event roomStateRequest : roomStateRequest(X)
Event roomStateEvent : roomStateEvent(X)
Event  addDish		: addDish(X)
Event  removeDish	: removeDish(X)

Event foodAvailable : foodAvailable(X)
Event foodUnavailable : foodUnavailable(X)
Event  alarm		: alarm(X)
Event  situationUnderControl	: situationUnderControl(X)
Event  sonar        : sonar(SONAR, DISTANCE)	 //from sonar in the robot environment   
Event  sonarRobot   : sonar( DISTANCE )	         //from  sonar on robot 
Event  polar        : p( Distance, Angle )          
 
Dispatch robotCmd   : robotCmd( CMD )

Context ctxBasicRobot ip [host="localhost" port=8005]   -mqtt

QActor basicrobot context ctxBasicRobot {
	["var ok_take_food = true"]
	State s0 initial {
 		//run itunibo.streams.sonarStreamPipe.create( myself ) //A stream pipe  
  		solve( consult("basicRobotConfig.pl") )   
 		solve( robot(R, PORT) )  //R = virtual | realmbot | realnano
 		//solve( consult("roomConfiguration.pl") )
 		//solve( pantry(PANTRY_X, PANTRY_Y) )
 		/*
 		solve( consult("roomConfiguration.pl") )
 		
 		solve( pantry(PANTRY_X, PANTRY_Y))
 		solve( table(TABLE_X, TABLE_Y))
 		solve( dishwasher(DISHWASHER_X, DISHWASHER_Y))
 		solve( fridge(FRIDGE_X, FRIDGE_Y))
 		* 
 		*/
 		
  		ifSolved{ println( "USING ROBOT : ${getCurSol(\"R\")},  port= ${getCurSol(\"PORT\")} " ) }
  		 else{ println("no robot") }
   		ifSolved{ 
   			run itunibo.robot.robotSupport.create(myself, @R, @PORT ) 
   			run itunibo.robot.plannerBhestie.create(myself)
   			run itunibo.robot.roomState.create(myself)
   			run itunibo.comunicationMessageClient.comunicationMessageClient.init(myself)
   			/*
   			run itunibo.robot.plannerBhestie.create(myself, @PORT, @PORT,
   				@PORT, @PORT,
   				@PORT, @PORT,
   				@PORT, @PORT)
   				* 
   				*/
   				
   				/* run itunibo.robot.plannerBhestie.create(myself, @PANTRY_X, @PANTRY_Y,
   				@TABLE_X, @TABLE_Y,
   				@DISHWASHER_X, @DISHWASHER_Y,
   				@FRIDGE_X, @FRIDGE_Y)*/
   			
   			/*
   			run itunibo.robot.plannerBhestie.create(myself, "${getCurSol(\"PANTRY_X\")}", "${getCurSol(\"PANTRY_Y\")}",
   				"${getCurSol(\"TABLE_X\")}", "${getCurSol(\"TABLE_Y\")}",
   				"${getCurSol(\"DISHWASHER_X\")}", "${getCurSol(\"DISHWASHER_Y\")}",
   				"${getCurSol(\"FRIDGE_X\")}", "${getCurSol(\"FRIDGE_Y\")}")
   				* 
   			*/
   		}
   		
   		//erano commentati
   		//run itunibo.robot.robotSupport.move( "msg(a)" )
   		//delay 700
   		//run itunibo.robot.robotSupport.move( "msg(d)" )
   		//delay 700
   		//run itunibo.robot.robotSupport.move( "msg(h)" )
   		//fine erano commentati
 	}  
	Goto waitCmd   
 	 
	State waitCmd{  } //userCmd comes from a console OUTSIDE this (sub)system
	Transition t0 whenEvent userCmd   -> handleUserCmd
		          whenMsg   robotCmd  -> handleUserCmd
		          whenEvent	maitreCmd -> handleMaitreCmd
		          whenEvent fridgeRequest -> handleFridgeRequest
		          whenEvent recvFoodMsgEvent -> handleRecvFoodMsgEvent
		          whenEvent roomStateRequest -> handleRoomStateRequest
		          whenEvent roomStateEvent -> handleRoomStateEvent
		          
	State handleRoomStateEvent{
		onMsg( roomStateEvent : roomStateEvent(X)){
			emit roomStateEvent : roomStateEvent($payloadArg(0))
		}
	}
	Goto waitCmd          
	
	State handleRoomStateRequest{
		println("I'M IN HANDLE ROOM STATE REQUEST")
		onMsg( roomStateRequest : roomStateRequest(X)){
			run itunibo.robot.roomState.emitRoomState()
		}
	}
	Goto waitCmd	          
	
	State handleFridgeRequest{
		println("I'M IN HANDLEFRIDGEREQUEST STATE")
		onMsg( fridgeRequest : fridgeRequest(X)){
			run itunibo.comunicationMessageClient.comunicationMessageClient.requestFoodList("msg(${payloadArg(0)})")
		}
	}
	Goto waitCmd
	
	State handleRecvFoodMsgEvent{
		println("I'M IN HANDLERECVFOODMSGEVENT STATE")
		onMsg( recvFoodMsgEvent : recvFoodMsgEvent(X)){
			emit recvFoodMsgEvent : recvFoodMsgEvent($payloadArg(0))
		}
	}
	
	Goto waitCmd
	
	
	
	State handleUserCmd{ //does not handle alarms 
		printCurrentMessage 
		onMsg( robotCmd : robotCmd( MOVE ) ) { //MOVE = w | a | s | d | h | l | r | i
			run itunibo.robot.robotSupport.move( "msg(${payloadArg(0)})" ) 
		}	
		onMsg( userCmd : userCmd( MOVE ) ) { //MOVE = w | a | s | d | h | l | r | i
 			run itunibo.robot.robotSupport.move( "msg(${payloadArg(0)})" ) 
		}
	}
	Goto waitCmd
	
	State handleMaitreCmd{
		println("I'M IN HANDLEMAITRECMD STATE")
		onMsg( maitreCmd : maitreCmd(ACTION)){
			println("I'M EXECUTING ACTION FROM HANDLEMAITRECMD")
			run itunibo.robot.plannerBhestie.action("msg(${payloadArg(0)})")
			//run itunibo.robot.virtualRobotJavaState.printState()
		}
	}
	Goto waitingPlannerDecision
	
	State waitingPlannerDecision{
		println("I'M IN WAITING PLANNER DECISION")
		onMsg( fridgeRequest : fridgeRequest(X)){
			println("RECEIVED FRIDGE REQUEST")
			run itunibo.comunicationMessageClient.comunicationMessageClient.requestFoodList("msg(${payloadArg(0)})")
		}
		onMsg( recvFoodMsgEvent : recvFoodMsgEvent(X)){
			println("RECEIVED FOODMSGEVENT")
			run itunibo.robot.plannerBhestie.evaluate_food_availability("msg(${payloadArg(0)})")
		}
		onMsg( foodAvailable : foodAvailable(X)){
			println("RECEIVED FOOD AVAILABLE")
			run itunibo.robot.plannerBhestie.requestNextMove()
		}
	}
	Transition t0 whenEvent foodUnavailable -> waitCmd
	whenEvent fridgeRequest -> waitingPlannerDecision
	whenEvent recvFoodMsgEvent -> waitingPlannerDecision
	whenEvent foodAvailable -> waitingPlannerDecision
	whenEvent plannerCmd -> progressPlanner
	
	
	State progressPlanner{
		println("I'M IN PROGRESS PLANNER STATE")
		onMsg( plannerCmd : plannerCmd(X)){
			run itunibo.robot.robotSupport.move( "msg(${payloadArg(0)})" )
			//run itunibo.robot.virtualRobotJavaState.printState()
			run itunibo.robot.robotSupport.waitAck()
		}
		onMsg( ackMsg : ackMsg(X)){
			run itunibo.robot.plannerBhestie.registerAck("${payloadArg(0)}")
			run itunibo.robot.plannerBhestie.requestNextMove()
		}
	}
	Transition t0 whenEvent alarm -> stopped
	whenEvent plannerCmd -> progressPlanner
	whenEvent ackMsg -> progressPlanner
	whenEvent endTaskEventCmd -> waitCmd
	/*whenEvent	plannerCmd -> waitAck*/
	
	
	/*
	State waitAck {
		println("I'M IN WAITACK STATE")
		run itunibo.robot.robotSupport.waitAck()
		onMsg( ackMsg : ackMsg(X)){
			run itunibo.robot.plannerBhestie.registerAck("msg(${payloadArg(0)})")
		}
	}
	Goto progressPlanner
	*/
	
	State stopped{}
	Transition t0 whenEvent	situationUnderControl -> resuming
	
	State resuming{
		run itunibo.robot.plannerBhestie.requestNextMove()
	}
	Transition t0 whenEvent plannerCmd -> progressPlanner
	
} 
 

QActor sonarhandler context ctxBasicRobot{  
 	State init initial{
		println("sonarhandler STARTS ... ")
	}         
	Goto waitForEvents
	   
	State waitForEvents{  }      
   	Transition t0 whenEvent sonar      ->  handleSonar
   	              whenEvent sonarRobot ->  handleSonar
   	               
 	State handleSonar{                      
 		printCurrentMessage                                        
 		onMsg ( sonar  : sonar( SONAR, DISTANCE ) ){    			
[" val D = Integer.parseInt( payloadArg(1) ) * 5"] //AMPLIFY
			emit polar : p( $D, 90  )  
 		}
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){     
[" val D = Integer.parseInt( payloadArg(0) ) * 5"] //AMPLIFY
			emit polar : p( $D, 180  ) 
 		}
 	} 
 	Goto waitForEvents
}